#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u32)]
pub enum OperationType {
    None = 0,
    Mov,
    Push,
    Pop,
    Xchg,
    In,
    Out,
    Xlat,
    Lea,
    Lds,
    Les,
    Lahf,
    Sahf,
    Pushf,
    Popf,
    Add,
    Adc,
    Inc,
    Aaa,
    Daa,
    Sub,
    Sbb,
    Dec,
    Neg,
    Cmp,
    Aas,
    Das,
    Mul,
    Imul,
    Aam,
    Div,
    Idiv,
    Aad,
    Cbw,
    Cwd,
    Not,
    Shl,
    Sal,
    Shr,
    Sar,
    Rol,
    Ror,
    Rcl,
    Rcr,
    And,
    Test,
    Or,
    Xor,
    Rep,
    Call,
    Jmp,
    Ret,
    Retf,
    Je,
    Jl,
    Jle,
    Jb,
    Jbe,
    Jp,
    Jo,
    Js,
    Jne,
    Jnl,
    Jg,
    Jnb,
    Ja,
    Jnp,
    Jno,
    Jns,
    Loop,
    Loopz,
    Loopnz,
    Jcxz,
    Int,
    Int3,
    Into,
    Iret,
    Clc,
    Cmc,
    Stc,
    Cld,
    Std,
    Cli,
    Sti,
    Hlt,
    Wait,
    Esc,
    Lock,
    Segment,
}

impl OperationType {
    pub fn mnemonic(&self) -> &'static str {
        match self {
            OperationType::None => "",
            OperationType::Mov => "mov",
            OperationType::Push => "push",
            OperationType::Pop => "pop",
            OperationType::Xchg => "xchg",
            OperationType::In => "in",
            OperationType::Out => "out",
            OperationType::Xlat => "xlat",
            OperationType::Lea => "lea",
            OperationType::Lds => "lds",
            OperationType::Les => "les",
            OperationType::Lahf => "lahf",
            OperationType::Sahf => "sahf",
            OperationType::Pushf => "pushf",
            OperationType::Popf => "popf",
            OperationType::Add => "add",
            OperationType::Adc => "adc",
            OperationType::Inc => "inc",
            OperationType::Aaa => "aaa",
            OperationType::Daa => "daa",
            OperationType::Sub => "sub",
            OperationType::Sbb => "sbb",
            OperationType::Dec => "dec",
            OperationType::Neg => "neg",
            OperationType::Cmp => "cmp",
            OperationType::Aas => "aas",
            OperationType::Das => "das",
            OperationType::Mul => "mul",
            OperationType::Imul => "imul",
            OperationType::Aam => "aam",
            OperationType::Div => "div",
            OperationType::Idiv => "idiv",
            OperationType::Aad => "aad",
            OperationType::Cbw => "cbw",
            OperationType::Cwd => "cwd",
            OperationType::Not => "not",
            OperationType::Shl => "shl",
            OperationType::Sal => "sal",
            OperationType::Shr => "shr",
            OperationType::Sar => "sar",
            OperationType::Rol => "rol",
            OperationType::Ror => "ror",
            OperationType::Rcl => "rcl",
            OperationType::Rcr => "rcr",
            OperationType::And => "and",
            OperationType::Test => "test",
            OperationType::Or => "or",
            OperationType::Xor => "xor",
            OperationType::Rep => "rep",
            OperationType::Call => "call",
            OperationType::Jmp => "jmp",
            OperationType::Ret => "ret",
            OperationType::Retf => "retf",
            OperationType::Je => "je",
            OperationType::Jl => "jl",
            OperationType::Jle => "jle",
            OperationType::Jb => "jb",
            OperationType::Jbe => "jbe",
            OperationType::Jp => "jp",
            OperationType::Jo => "jo",
            OperationType::Js => "js",
            OperationType::Jne => "jne",
            OperationType::Jnl => "jnl",
            OperationType::Jg => "jg",
            OperationType::Jnb => "jnb",
            OperationType::Ja => "ja",
            OperationType::Jnp => "jnp",
            OperationType::Jno => "jno",
            OperationType::Jns => "jns",
            OperationType::Loop => "loop",
            OperationType::Loopz => "loopz",
            OperationType::Loopnz => "loopnz",
            OperationType::Jcxz => "jcxz",
            OperationType::Int => "int",
            OperationType::Int3 => "int3",
            OperationType::Into => "into",
            OperationType::Iret => "iret",
            OperationType::Clc => "clc",
            OperationType::Cmc => "cmc",
            OperationType::Stc => "stc",
            OperationType::Cld => "cld",
            OperationType::Std => "std",
            OperationType::Cli => "cli",
            OperationType::Sti => "sti",
            OperationType::Hlt => "hlt",
            OperationType::Wait => "wait",
            OperationType::Esc => "esc",
            OperationType::Lock => "lock",
            OperationType::Segment => "segment",
        }
    }
}

// Instruction bits and decoding
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u8)]
pub enum InstructionBitsUsage {
    Literal,
    Mod,
    Reg,
    Rm,
    Sr,
    Disp,
    Data,
    HasDisp,
    DispAlwaysW,
    HasData,
    WMakesDataW,
    RmRegAlwaysW,
    RelJmpDisp,
    D,
    S,
    W,
    V,
    Z,
}

#[derive(Debug, Clone, Copy)]
pub struct InstructionBits {
    pub usage: InstructionBitsUsage,
    pub bit_count: u8,
    pub shift: u8,
    pub value: u8,
}

#[derive(Debug, Clone)]
pub struct InstructionFormat {
    pub op: OperationType,
    pub bits: Vec<InstructionBits>,
}

pub fn get_instruction_formats() -> Vec<InstructionFormat> {
    vec![
        // MOV register/memory to/from register - 100010dw mod reg r/m
        InstructionFormat {
            op: OperationType::Mov,
            bits: vec![
                InstructionBits { usage: InstructionBitsUsage::Literal, bit_count: 6, shift: 0, value: 0b100010 },
                InstructionBits { usage: InstructionBitsUsage::D, bit_count: 1, shift: 0, value: 0 },
                InstructionBits { usage: InstructionBitsUsage::W, bit_count: 1, shift: 0, value: 0 },
                InstructionBits { usage: InstructionBitsUsage::Mod, bit_count: 2, shift: 0, value: 0 },
                InstructionBits { usage: InstructionBitsUsage::Reg, bit_count: 3, shift: 0, value: 0 },
                InstructionBits { usage: InstructionBitsUsage::Rm, bit_count: 3, shift: 0, value: 0 },
            ],
        },
        // MOV immediate to register - 1011wreg data
        InstructionFormat {
            op: OperationType::Mov,
            bits: vec![
                InstructionBits { usage: InstructionBitsUsage::Literal, bit_count: 4, shift: 0, value: 0b1011 },
                InstructionBits { usage: InstructionBitsUsage::W, bit_count: 1, shift: 0, value: 0 },
                InstructionBits { usage: InstructionBitsUsage::Reg, bit_count: 3, shift: 0, value: 0 },
                InstructionBits { usage: InstructionBitsUsage::HasData, bit_count: 0, shift: 0, value: 1 },
                InstructionBits { usage: InstructionBitsUsage::WMakesDataW, bit_count: 0, shift: 0, value: 1 },
            ],
        },
        InstructionFormat {
            op: OperationType::Jmp,
            bits: vec![
                InstructionBits { usage: InstructionBitsUsage::Literal, bit_count: 8, shift: 0, value: 0xE9 },
                InstructionBits { usage: InstructionBitsUsage::HasDisp, bit_count: 0, shift: 0, value: 1 },
                InstructionBits { usage: InstructionBitsUsage::DispAlwaysW, bit_count: 0, shift: 0, value: 1 },
                InstructionBits { usage: InstructionBitsUsage::RelJmpDisp, bit_count: 0, shift: 0, value: 1 },
            ],
        },
        InstructionFormat {
            op: OperationType::Je,
            bits: vec![
                InstructionBits { usage: InstructionBitsUsage::Literal, bit_count: 8, shift: 0, value: 0x74 },
                InstructionBits { usage: InstructionBitsUsage::HasDisp, bit_count: 0, shift: 0, value: 1 },
                InstructionBits { usage: InstructionBitsUsage::RelJmpDisp, bit_count: 0, shift: 0, value: 1 },
            ],
        },
    ]
}

